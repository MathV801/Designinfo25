<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Explosion de texte (canvas)</title>
  <style>
    :root { --bg: #0b1220; --text: #ffd166; }
    html,body { height:100%; margin:0; }
    body {
      background: radial-gradient(circle at 20% 10%, #071226 0%, #0b1220 40%, #030409 100%);
      display:flex;
      align-items:center;
      justify-content:center;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:var(--text);
      overflow:hidden;
    }
    canvas {
      display:block;
      /* canvas is full-viewport but visually center is managed in code */
    }
    /* small hint */
    .hint {
      position:fixed;
      left:12px;
      bottom:12px;
      color:rgba(255,209,102,0.85);
      font-size:0.9rem;
      user-select:none;
      pointer-events:none;
      text-shadow:0 1px 0 rgba(0,0,0,0.6);
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hint">Clique n'importe où — le texte explose en caractères.</div>

  <script>
    // ----- Configuration -----
    const PHRASE = "Cliquez et regardez : le texte explose !";
    const BASE_FONT = "900"; // font-weight (string) or number
    const FONT_FAMILY = "system-ui, -apple-system, 'Segoe UI', Roboto, Arial";
    const FONT_SIZE_VW = 6.5; // taille approximative en viewport-width (responsive)
    const GRAVITY = 0.45;
    const FRICTION = 0.995;
    const PARTICLE_TTL = 2800; // durée (ms) avant disparition complète approximative
    const PARTICLE_SPREAD = 6; // intensité de la vitesse initiale

    // ----- Setup canvas with DPR scaling -----
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });
    let DPR = Math.max(1, window.devicePixelRatio || 1);

    function fitCanvas() {
      DPR = Math.max(1, window.devicePixelRatio || 1);
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      ctx.setTransform(DPR,0,0,DPR,0,0); // work in CSS pixels
      drawStaticText(); // redraw centered text
    }
    window.addEventListener("resize", fitCanvas, { passive: true });

    // ----- Text rendering helpers -----
    function computeFontSize() {
      // responsive font-size based on viewport width
      return Math.max(18, window.innerWidth * (FONT_SIZE_VW / 100));
    }
    function setTextStyle() {
      const size = computeFontSize();
      ctx.font = `${BASE_FONT} ${size}px ${FONT_FAMILY}`;
      ctx.textBaseline = "middle";
      ctx.fillStyle = "white";
      ctx.textAlign = "left";
    }

    // Draw the phrase centered on screen (static)
    function drawStaticText() {
      clearBackground();
      setTextStyle();
      const size = computeFontSize();
      const metrics = ctx.measureText(PHRASE);
      const textWidth = metrics.width;
      const x = (canvas.width / DPR - textWidth) / 2;
      const y = (canvas.height / DPR) / 2;
      // subtle glow / stroke for visibility
      ctx.save();
      ctx.shadowColor = "rgba(255,180,90,0.08)";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#ffd166";
      ctx.fillText(PHRASE, x, y);
      ctx.restore();
    }

    function clearBackground() {
      ctx.fillStyle = "#04060a"; // dark background erase
      ctx.fillRect(0,0, canvas.width / DPR, canvas.height / DPR);
    }

    // ----- Particle system (one particle per character) -----
    let particles = [];
    let animating = false;

    class CharParticle {
      constructor(char, x, y, color) {
        this.char = char;
        this.x = x;
        this.y = y;
        // random outward velocity
        const angle = (Math.random() * Math.PI * 2);
        const speedBase = (Math.random() * PARTICLE_SPREAD) + 1.6;
        this.vx = Math.cos(angle) * speedBase * (Math.random()*1.4);
        this.vy = Math.sin(angle) * speedBase * (Math.random()*0.6 - 1.5); // upward bias
        // small random rotation
        this.a = Math.random() * 2 * Math.PI;
        this.va = (Math.random() - 0.5) * 0.25;
        this.alpha = 1;
        this.birth = performance.now();
        this.color = color || "#ffd166";
        // size slightly random
        this.size = computeFontSize() * (0.9 + Math.random() * 0.4);
      }

      update(dt) {
        // dt in ms
        this.vy += GRAVITY * (dt/16.67); // scale gravity by frame time
        this.vx *= FRICTION;
        this.vy *= FRICTION;
        this.x += this.vx;
        this.y += this.vy;
        this.a += this.va;
        // fade based on time
        const age = performance.now() - this.birth;
        this.alpha = Math.max(0, 1 - age / PARTICLE_TTL);
      }

      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.a);
        ctx.fillStyle = this.color;
        ctx.font = `900 ${this.size}px ${FONT_FAMILY}`;
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ctx.fillText(this.char, 0, 0);
        ctx.restore();
      }

      isDead() {
        if (this.alpha <= 0.01) return true;
        if (this.y > canvas.height/DPR + 80) return true;
        return false;
      }
    }

    // Create particles positioned for each character's center
    function explodeText() {
      setTextStyle();
      const size = computeFontSize();
      const metrics = ctx.measureText(PHRASE);
      const totalWidth = metrics.width;
      const startX = (canvas.width / DPR - totalWidth) / 2;
      const baselineY = (canvas.height / DPR) / 2;

      // compute each char width and position
      let x = startX;
      for (let i = 0; i < PHRASE.length; i++) {
        const ch = PHRASE[i];
        const w = ctx.measureText(ch).width;
        // center of this char
        const cx = x + w / 2;
        const cy = baselineY;
        // color per character (subtle randomization)
        const hue = 40 + Math.random()*30; // warm tone
        const color = `hsl(${hue} ${80 + Math.random()*10}% ${55 + Math.random()*10}%)`;
        particles.push(new CharParticle(ch, cx, cy, color));
        x += w;
      }

      // start animation loop if not already
      if (!animating) {
        animating = true;
        requestAnimationFrame(loop);
      }
    }

    // Animation loop
    let lastTime = 0;
    function loop(ts) {
      if (!lastTime) lastTime = ts;
      const dt = ts - lastTime;
      lastTime = ts;

      clearBackground();

      // update & draw particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update(dt);
        p.draw(ctx);
        if (p.isDead()) particles.splice(i,1);
      }

      // if no particles: draw static text again and stop animating
      if (particles.length === 0) {
        animating = false;
        lastTime = 0;
        // re-draw static text after a tiny delay to avoid flicker
        setTimeout(drawStaticText, 50);
        return;
      }

      requestAnimationFrame(loop);
    }

    // ----- Interaction: click anywhere to explode -----
    window.addEventListener("pointerdown", (e) => {
      // if currently animating (particles active), ignore new clicks to avoid overlap
      if (particles.length > 0) return;
      // ensure centered phrase visible right before explosion
      drawStaticText();
      // small timeout to ensure draw completed (not strictly required)
      setTimeout(explodeText, 40);
    });

    // initial setup
    fitCanvas();
    // initial draw already called by fitCanvas -> drawStaticText
  </script>
</body>
</html>
